{"version":3,"file":"models/models.js","mappings":";;AAAA;AACA;AACA;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://hiccup/webpack/bootstrap","webpack://hiccup/webpack/runtime/define property getters","webpack://hiccup/webpack/runtime/hasOwnProperty shorthand","webpack://hiccup/webpack/runtime/make namespace object","webpack://hiccup/./models/notes.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export class Note {\n    constructor(title, folderID) {\n        this.embedding = [];\n        this.sites = [];\n        this.content = \"\";\n        this.title = title.trim();\n        this.id = crypto.randomUUID();\n        this.createdAt = Date.now();\n        this.lastUpdate = Date.now();\n        this.words = 0;\n        if (folderID) {\n            this.folderID = folderID;\n            this.save(folderID);\n        }\n    }\n    async save(folderID) {\n        if (!this.folderID) {\n            throw new Error(\"Missing Path\");\n        }\n        await chrome.storage.local.set({\n            [`${folderID}/meta_${this.id}`]: {\n                id: this.id,\n                title: this.title,\n                createdAt: this.createdAt,\n                lastUpdate: this.lastUpdate,\n                words: this.words,\n                embedding: this.embedding,\n                sites: this.sites,\n            }\n        });\n        this.folderID = folderID;\n        await chrome.storage.local.set({\n            [`${folderID}/content_${this.id}`]: this.content\n        });\n    }\n    async getMeta() {\n        const result = await chrome.storage.local.get(`${this.folderID}/meta_${this.id}`);\n        return result[`${this.folderID}/meta_${this.id}`];\n    }\n    async getContent() {\n        const result = await chrome.storage.local.get(`${this.folderID}/content_${this.id}`);\n        return result[`${this.folderID}/content_${this.id}`];\n    }\n    async delete() {\n        await chrome.storage.local.remove([\n            `${this.folderID}/meta_${this.id}`,\n            `${this.folderID}/content_${this.id}`\n        ]);\n    }\n    update(content) {\n        this.lastUpdate = Date.now();\n        this.content = content;\n        this.words = content.trim().split(/\\s+/).length;\n        if (this.folderID) {\n            this.save(this.folderID);\n        }\n        else\n            throw new Error(\"Missing Path\");\n    }\n}\nexport function addNote(title, path) {\n    const note = new Note(title, path);\n    return note.id;\n}\n"],"names":[],"sourceRoot":""}